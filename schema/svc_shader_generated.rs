// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod service {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
pub mod shader {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;
pub mod schema {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum InputFormat {
  /// HLSL input
  Hlsl = 0,
  /// Glsl input
  Glsl = 1,

}

const ENUM_MIN_INPUT_FORMAT: i8 = 0;
const ENUM_MAX_INPUT_FORMAT: i8 = 1;

impl<'a> flatbuffers::Follow<'a> for InputFormat {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for InputFormat {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const InputFormat;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const InputFormat;
    unsafe { *p }
  }
}

impl flatbuffers::Push for InputFormat {
    type Output = InputFormat;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<InputFormat>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_INPUT_FORMAT:[InputFormat; 2] = [
  InputFormat::Hlsl,
  InputFormat::Glsl
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_INPUT_FORMAT:[&'static str; 2] = [
    "Hlsl",
    "Glsl"
];

pub fn enum_name_input_format(e: InputFormat) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_INPUT_FORMAT[index]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum OutputFormat {
  /// DXIL output
  Dxil = 0,
  /// SPIR-V output
  Spirv = 1,
  /// SPIR-V output (SMOL-V encoded)
  Smolv = 2,
  /// Text listing output
  Text = 3,
  /// Binary blob output
  Blob = 4,

}

const ENUM_MIN_OUTPUT_FORMAT: i8 = 0;
const ENUM_MAX_OUTPUT_FORMAT: i8 = 4;

impl<'a> flatbuffers::Follow<'a> for OutputFormat {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for OutputFormat {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const OutputFormat;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const OutputFormat;
    unsafe { *p }
  }
}

impl flatbuffers::Push for OutputFormat {
    type Output = OutputFormat;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<OutputFormat>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_OUTPUT_FORMAT:[OutputFormat; 5] = [
  OutputFormat::Dxil,
  OutputFormat::Spirv,
  OutputFormat::Smolv,
  OutputFormat::Text,
  OutputFormat::Blob
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_OUTPUT_FORMAT:[&'static str; 5] = [
    "Dxil",
    "Spirv",
    "Smolv",
    "Text",
    "Blob"
];

pub fn enum_name_output_format(e: OutputFormat) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_OUTPUT_FORMAT[index]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Profile {
  Compute = 0,
  Geometry = 1,
  Vertex = 2,
  Pixel = 3,
  Hull = 4,
  Domain = 5,
  Task = 6,
  Mesh = 7,
  RayGen = 8,
  RayIntersection = 9,
  RayClosestHit = 10,
  RayAnyHit = 11,
  RayMiss = 12,

}

const ENUM_MIN_PROFILE: i8 = 0;
const ENUM_MAX_PROFILE: i8 = 12;

impl<'a> flatbuffers::Follow<'a> for Profile {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Profile {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const Profile;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const Profile;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Profile {
    type Output = Profile;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Profile>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_PROFILE:[Profile; 13] = [
  Profile::Compute,
  Profile::Geometry,
  Profile::Vertex,
  Profile::Pixel,
  Profile::Hull,
  Profile::Domain,
  Profile::Task,
  Profile::Mesh,
  Profile::RayGen,
  Profile::RayIntersection,
  Profile::RayClosestHit,
  Profile::RayAnyHit,
  Profile::RayMiss
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_PROFILE:[&'static str; 13] = [
    "Compute",
    "Geometry",
    "Vertex",
    "Pixel",
    "Hull",
    "Domain",
    "Task",
    "Mesh",
    "RayGen",
    "RayIntersection",
    "RayClosestHit",
    "RayAnyHit",
    "RayMiss"
];

pub fn enum_name_profile(e: Profile) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_PROFILE[index]
}

pub enum ArtifactOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Artifact<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Artifact<'a> {
    type Inner = Artifact<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Artifact<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Artifact {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ArtifactArgs<'args>) -> flatbuffers::WIPOffset<Artifact<'bldr>> {
      let mut builder = ArtifactBuilder::new(_fbb);
      if let Some(x) = args.data { builder.add_data(x); }
      if let Some(x) = args.encoding { builder.add_encoding(x); }
      if let Some(x) = args.identity { builder.add_identity(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_validated(args.validated);
      builder.add_profile(args.profile);
      builder.add_output(args.output);
      builder.add_input(args.input);
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT: flatbuffers::VOffsetT = 6;
    pub const VT_OUTPUT: flatbuffers::VOffsetT = 8;
    pub const VT_IDENTITY: flatbuffers::VOffsetT = 10;
    pub const VT_ENCODING: flatbuffers::VOffsetT = 12;
    pub const VT_PROFILE: flatbuffers::VOffsetT = 14;
    pub const VT_VALIDATED: flatbuffers::VOffsetT = 16;
    pub const VT_DATA: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Artifact::VT_NAME, None)
  }
  #[inline]
  pub fn input(&self) -> InputFormat {
    self._tab.get::<InputFormat>(Artifact::VT_INPUT, Some(InputFormat::Hlsl)).unwrap()
  }
  #[inline]
  pub fn output(&self) -> OutputFormat {
    self._tab.get::<OutputFormat>(Artifact::VT_OUTPUT, Some(OutputFormat::Dxil)).unwrap()
  }
  #[inline]
  pub fn identity(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Artifact::VT_IDENTITY, None)
  }
  #[inline]
  pub fn encoding(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Artifact::VT_ENCODING, None)
  }
  #[inline]
  pub fn profile(&self) -> Profile {
    self._tab.get::<Profile>(Artifact::VT_PROFILE, Some(Profile::Compute)).unwrap()
  }
  #[inline]
  pub fn validated(&self) -> bool {
    self._tab.get::<bool>(Artifact::VT_VALIDATED, Some(false)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Artifact::VT_DATA, None).map(|v| v.safe_slice())
  }
}

pub struct ArtifactArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub input: InputFormat,
    pub output: OutputFormat,
    pub identity: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub encoding: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub profile: Profile,
    pub validated: bool,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for ArtifactArgs<'a> {
    #[inline]
    fn default() -> Self {
        ArtifactArgs {
            name: None,
            input: InputFormat::Hlsl,
            output: OutputFormat::Dxil,
            identity: None,
            encoding: None,
            profile: Profile::Compute,
            validated: false,
            data: None,
        }
    }
}
pub struct ArtifactBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArtifactBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Artifact::VT_NAME, name);
  }
  #[inline]
  pub fn add_input(&mut self, input: InputFormat) {
    self.fbb_.push_slot::<InputFormat>(Artifact::VT_INPUT, input, InputFormat::Hlsl);
  }
  #[inline]
  pub fn add_output(&mut self, output: OutputFormat) {
    self.fbb_.push_slot::<OutputFormat>(Artifact::VT_OUTPUT, output, OutputFormat::Dxil);
  }
  #[inline]
  pub fn add_identity(&mut self, identity: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Artifact::VT_IDENTITY, identity);
  }
  #[inline]
  pub fn add_encoding(&mut self, encoding: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Artifact::VT_ENCODING, encoding);
  }
  #[inline]
  pub fn add_profile(&mut self, profile: Profile) {
    self.fbb_.push_slot::<Profile>(Artifact::VT_PROFILE, profile, Profile::Compute);
  }
  #[inline]
  pub fn add_validated(&mut self, validated: bool) {
    self.fbb_.push_slot::<bool>(Artifact::VT_VALIDATED, validated, false);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Artifact::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArtifactBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArtifactBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Artifact<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ShaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Shader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Shader<'a> {
    type Inner = Shader<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Shader<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Shader {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ShaderArgs<'args>) -> flatbuffers::WIPOffset<Shader<'bldr>> {
      let mut builder = ShaderBuilder::new(_fbb);
      if let Some(x) = args.artifacts { builder.add_artifacts(x); }
      if let Some(x) = args.entry { builder.add_entry(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_ENTRY: flatbuffers::VOffsetT = 6;
    pub const VT_ARTIFACTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Shader::VT_NAME, None)
  }
  #[inline]
  pub fn entry(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Shader::VT_ENTRY, None)
  }
  #[inline]
  pub fn artifacts(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Artifact<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Artifact<'a>>>>>(Shader::VT_ARTIFACTS, None)
  }
}

pub struct ShaderArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub entry: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub artifacts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Artifact<'a >>>>>,
}
impl<'a> Default for ShaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        ShaderArgs {
            name: None,
            entry: None,
            artifacts: None,
        }
    }
}
pub struct ShaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ShaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Shader::VT_NAME, name);
  }
  #[inline]
  pub fn add_entry(&mut self, entry: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Shader::VT_ENTRY, entry);
  }
  #[inline]
  pub fn add_artifacts(&mut self, artifacts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Artifact<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Shader::VT_ARTIFACTS, artifacts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ShaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ShaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Shader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ManifestOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Manifest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Manifest<'a> {
    type Inner = Manifest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Manifest<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Manifest {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ManifestArgs<'args>) -> flatbuffers::WIPOffset<Manifest<'bldr>> {
      let mut builder = ManifestBuilder::new(_fbb);
      if let Some(x) = args.shaders { builder.add_shaders(x); }
      builder.finish()
    }

    pub const VT_SHADERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn shaders(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Shader<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Shader<'a>>>>>(Manifest::VT_SHADERS, None)
  }
}

pub struct ManifestArgs<'a> {
    pub shaders: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Shader<'a >>>>>,
}
impl<'a> Default for ManifestArgs<'a> {
    #[inline]
    fn default() -> Self {
        ManifestArgs {
            shaders: None,
        }
    }
}
pub struct ManifestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ManifestBuilder<'a, 'b> {
  #[inline]
  pub fn add_shaders(&mut self, shaders: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Shader<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_SHADERS, shaders);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ManifestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ManifestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Manifest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_manifest<'a>(buf: &'a [u8]) -> Manifest<'a> {
  flatbuffers::get_root::<Manifest<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_manifest<'a>(buf: &'a [u8]) -> Manifest<'a> {
  flatbuffers::get_size_prefixed_root::<Manifest<'a>>(buf)
}

#[inline]
pub fn finish_manifest_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Manifest<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_manifest_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Manifest<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod schema
}  // pub mod shader
}  // pub mod service

