// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SVCSHADER_SERVICE_SHADER_SCHEMA_H_
#define FLATBUFFERS_GENERATED_SVCSHADER_SERVICE_SHADER_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace service {
namespace shader {
namespace schema {

struct Artifact;

struct Shader;

struct Manifest;

enum InputFormat {
  /// HLSL input
  InputFormat_Hlsl = 0  /// Glsl input
,
  InputFormat_Glsl = 1,
  InputFormat_MIN = InputFormat_Hlsl,
  InputFormat_MAX = InputFormat_Glsl
};

inline const InputFormat (&EnumValuesInputFormat())[2] {
  static const InputFormat values[] = {
    InputFormat_Hlsl,
    InputFormat_Glsl
  };
  return values;
}

inline const char * const *EnumNamesInputFormat() {
  static const char * const names[] = {
    "Hlsl",
    "Glsl",
    nullptr
  };
  return names;
}

inline const char *EnumNameInputFormat(InputFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesInputFormat()[index];
}

enum OutputFormat {
  /// DXIL output
  OutputFormat_Dxil = 0  /// SPIR-V output
,
  OutputFormat_Spirv = 1  /// SPIR-V output (SMOL-V encoded)
,
  OutputFormat_Smolv = 2  /// Text listing output
,
  OutputFormat_Text = 3  /// Binary blob output
,
  OutputFormat_Blob = 4,
  OutputFormat_MIN = OutputFormat_Dxil,
  OutputFormat_MAX = OutputFormat_Blob
};

inline const OutputFormat (&EnumValuesOutputFormat())[5] {
  static const OutputFormat values[] = {
    OutputFormat_Dxil,
    OutputFormat_Spirv,
    OutputFormat_Smolv,
    OutputFormat_Text,
    OutputFormat_Blob
  };
  return values;
}

inline const char * const *EnumNamesOutputFormat() {
  static const char * const names[] = {
    "Dxil",
    "Spirv",
    "Smolv",
    "Text",
    "Blob",
    nullptr
  };
  return names;
}

inline const char *EnumNameOutputFormat(OutputFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOutputFormat()[index];
}

enum Profile {
  Profile_Compute = 0,
  Profile_Geometry = 1,
  Profile_Vertex = 2,
  Profile_Pixel = 3,
  Profile_Hull = 4,
  Profile_Domain = 5,
  Profile_Task = 6,
  Profile_Mesh = 7,
  Profile_RayGen = 8,
  Profile_RayIntersection = 9,
  Profile_RayClosestHit = 10,
  Profile_RayAnyHit = 11,
  Profile_RayMiss = 12,
  Profile_MIN = Profile_Compute,
  Profile_MAX = Profile_RayMiss
};

inline const Profile (&EnumValuesProfile())[13] {
  static const Profile values[] = {
    Profile_Compute,
    Profile_Geometry,
    Profile_Vertex,
    Profile_Pixel,
    Profile_Hull,
    Profile_Domain,
    Profile_Task,
    Profile_Mesh,
    Profile_RayGen,
    Profile_RayIntersection,
    Profile_RayClosestHit,
    Profile_RayAnyHit,
    Profile_RayMiss
  };
  return values;
}

inline const char * const *EnumNamesProfile() {
  static const char * const names[] = {
    "Compute",
    "Geometry",
    "Vertex",
    "Pixel",
    "Hull",
    "Domain",
    "Task",
    "Mesh",
    "RayGen",
    "RayIntersection",
    "RayClosestHit",
    "RayAnyHit",
    "RayMiss",
    nullptr
  };
  return names;
}

inline const char *EnumNameProfile(Profile e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesProfile()[index];
}

struct Artifact FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_INPUT = 6,
    VT_OUTPUT = 8,
    VT_IDENTITY = 10,
    VT_ENCODING = 12,
    VT_PROFILE = 14,
    VT_VALIDATED = 16,
    VT_DATA = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  InputFormat input() const {
    return static_cast<InputFormat>(GetField<int8_t>(VT_INPUT, 0));
  }
  OutputFormat output() const {
    return static_cast<OutputFormat>(GetField<int8_t>(VT_OUTPUT, 0));
  }
  const flatbuffers::String *identity() const {
    return GetPointer<const flatbuffers::String *>(VT_IDENTITY);
  }
  const flatbuffers::String *encoding() const {
    return GetPointer<const flatbuffers::String *>(VT_ENCODING);
  }
  Profile profile() const {
    return static_cast<Profile>(GetField<int8_t>(VT_PROFILE, 0));
  }
  bool validated() const {
    return GetField<uint8_t>(VT_VALIDATED, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_INPUT) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT) &&
           VerifyOffset(verifier, VT_IDENTITY) &&
           verifier.VerifyString(identity()) &&
           VerifyOffset(verifier, VT_ENCODING) &&
           verifier.VerifyString(encoding()) &&
           VerifyField<int8_t>(verifier, VT_PROFILE) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATED) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ArtifactBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Artifact::VT_NAME, name);
  }
  void add_input(InputFormat input) {
    fbb_.AddElement<int8_t>(Artifact::VT_INPUT, static_cast<int8_t>(input), 0);
  }
  void add_output(OutputFormat output) {
    fbb_.AddElement<int8_t>(Artifact::VT_OUTPUT, static_cast<int8_t>(output), 0);
  }
  void add_identity(flatbuffers::Offset<flatbuffers::String> identity) {
    fbb_.AddOffset(Artifact::VT_IDENTITY, identity);
  }
  void add_encoding(flatbuffers::Offset<flatbuffers::String> encoding) {
    fbb_.AddOffset(Artifact::VT_ENCODING, encoding);
  }
  void add_profile(Profile profile) {
    fbb_.AddElement<int8_t>(Artifact::VT_PROFILE, static_cast<int8_t>(profile), 0);
  }
  void add_validated(bool validated) {
    fbb_.AddElement<uint8_t>(Artifact::VT_VALIDATED, static_cast<uint8_t>(validated), 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Artifact::VT_DATA, data);
  }
  explicit ArtifactBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArtifactBuilder &operator=(const ArtifactBuilder &);
  flatbuffers::Offset<Artifact> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Artifact>(end);
    return o;
  }
};

inline flatbuffers::Offset<Artifact> CreateArtifact(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    InputFormat input = InputFormat_Hlsl,
    OutputFormat output = OutputFormat_Dxil,
    flatbuffers::Offset<flatbuffers::String> identity = 0,
    flatbuffers::Offset<flatbuffers::String> encoding = 0,
    Profile profile = Profile_Compute,
    bool validated = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ArtifactBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_encoding(encoding);
  builder_.add_identity(identity);
  builder_.add_name(name);
  builder_.add_validated(validated);
  builder_.add_profile(profile);
  builder_.add_output(output);
  builder_.add_input(input);
  return builder_.Finish();
}

inline flatbuffers::Offset<Artifact> CreateArtifactDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    InputFormat input = InputFormat_Hlsl,
    OutputFormat output = OutputFormat_Dxil,
    const char *identity = nullptr,
    const char *encoding = nullptr,
    Profile profile = Profile_Compute,
    bool validated = false,
    const std::vector<uint8_t> *data = nullptr) {
  return service::shader::schema::CreateArtifact(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      input,
      output,
      identity ? _fbb.CreateString(identity) : 0,
      encoding ? _fbb.CreateString(encoding) : 0,
      profile,
      validated,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

struct Shader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_ENTRY = 6,
    VT_ARTIFACTS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *entry() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTRY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Artifact>> *artifacts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Artifact>> *>(VT_ARTIFACTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ENTRY) &&
           verifier.VerifyString(entry()) &&
           VerifyOffset(verifier, VT_ARTIFACTS) &&
           verifier.VerifyVector(artifacts()) &&
           verifier.VerifyVectorOfTables(artifacts()) &&
           verifier.EndTable();
  }
};

struct ShaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Shader::VT_NAME, name);
  }
  void add_entry(flatbuffers::Offset<flatbuffers::String> entry) {
    fbb_.AddOffset(Shader::VT_ENTRY, entry);
  }
  void add_artifacts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Artifact>>> artifacts) {
    fbb_.AddOffset(Shader::VT_ARTIFACTS, artifacts);
  }
  explicit ShaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderBuilder &operator=(const ShaderBuilder &);
  flatbuffers::Offset<Shader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shader>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shader> CreateShader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> entry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Artifact>>> artifacts = 0) {
  ShaderBuilder builder_(_fbb);
  builder_.add_artifacts(artifacts);
  builder_.add_entry(entry);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Shader> CreateShaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *entry = nullptr,
    const std::vector<flatbuffers::Offset<Artifact>> *artifacts = nullptr) {
  return service::shader::schema::CreateShader(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      entry ? _fbb.CreateString(entry) : 0,
      artifacts ? _fbb.CreateVector<flatbuffers::Offset<Artifact>>(*artifacts) : 0);
}

struct Manifest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHADERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Shader>> *shaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Shader>> *>(VT_SHADERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHADERS) &&
           verifier.VerifyVector(shaders()) &&
           verifier.VerifyVectorOfTables(shaders()) &&
           verifier.EndTable();
  }
};

struct ManifestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Shader>>> shaders) {
    fbb_.AddOffset(Manifest::VT_SHADERS, shaders);
  }
  explicit ManifestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ManifestBuilder &operator=(const ManifestBuilder &);
  flatbuffers::Offset<Manifest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Manifest>(end);
    return o;
  }
};

inline flatbuffers::Offset<Manifest> CreateManifest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Shader>>> shaders = 0) {
  ManifestBuilder builder_(_fbb);
  builder_.add_shaders(shaders);
  return builder_.Finish();
}

inline flatbuffers::Offset<Manifest> CreateManifestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Shader>> *shaders = nullptr) {
  return service::shader::schema::CreateManifest(
      _fbb,
      shaders ? _fbb.CreateVector<flatbuffers::Offset<Shader>>(*shaders) : 0);
}

inline const service::shader::schema::Manifest *GetManifest(const void *buf) {
  return flatbuffers::GetRoot<service::shader::schema::Manifest>(buf);
}

inline const service::shader::schema::Manifest *GetSizePrefixedManifest(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<service::shader::schema::Manifest>(buf);
}

inline bool VerifyManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<service::shader::schema::Manifest>(nullptr);
}

inline bool VerifySizePrefixedManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<service::shader::schema::Manifest>(nullptr);
}

inline void FinishManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<service::shader::schema::Manifest> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<service::shader::schema::Manifest> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace schema
}  // namespace shader
}  // namespace service

#endif  // FLATBUFFERS_GENERATED_SVCSHADER_SERVICE_SHADER_SCHEMA_H_
